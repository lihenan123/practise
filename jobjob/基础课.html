1.http有没有设置缓存？
	http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。
	1.浏览器缓存是把页面信息保存到用户本地硬盘里，页面缓存状态是由http header决定的
	2.代理服务器缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。

3.如何处理资源竞争（进程同时访问一个资源）
	1临界区（加锁）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
	2互斥量（加锁）:为协调共同对一个共享资源的单独访问而设计的。（0，1）
	3信号量（P/V操作）:为控制一个具有有限数量用户资源而设计。p（s1）v（s1）p使s1加，v使s1减
	4事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

临界资源：指某段时间只能允许一个进程使用资源。
临界区（代码），专门访问临界资源的

4.函数调用和系统调用的区别？
	一般函数调用即函数库调用是语言或应用程序的一部分，
	而系统调用是操作系统的一部分。你要确保弄懂“trap（自陷）”这个关键字的含义。系统调用是在操作系统内核发现一个“trap”或中断后进行的。

5.操作统中锁的实现原理
	在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。
	内存中的一个变量，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

6.保证完整性：事务
	事务的四个特性：
	1.原子性：要么全部都成功，要么全都不成功。2.一致性：数据必须处于一致的状态。3.隔离性：多个事务同时进行，它们之间互相干扰。4.持久性：提交后不能更改。


8.基本封锁类型
	排它锁（Exclusive Locks，简记为X锁，写锁）
		若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
		保证其他事务在T释放A上的锁之前不能再读取和修改A
	共享锁（Share Locks，简记为S锁，读锁）
		若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
		保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改



7.数据并发的问题
	丢失修改
	读“脏”数据(脏数据就是在物理上临时存在过，但在逻辑上不存在的数据。)
		比如说，有两个用户A，B同时操作数据库，A开始了一个事务，修改了某行，但还未提交，这个时候，B开始另一个事务，读取了该行，然后A回滚了事务，即修改被取消了，那么，B读取到的那一行数据就是脏数据。
	不可重复读

9.三级封锁协议解决数据并发的问题
	一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
	二级封锁协议：一级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁。
	三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。


8\如何解决高并发问题?
	1\数据库
	2\HTML静态化:效率最高、消耗最小的就是纯静态化 页面
		网站HTML静态化解决方案 
		当一个Servlet资源请求到达WEB服务器之后我们会填充指定的JSP页面来响应请求:
		HTTP请求---Web服务器---Servlet--业务逻辑处理--访问数据--填充JSP--响应请求
		HTML静态化之后:
		HTTP请求---Web服务器---Servlet--HTML--响应请求
	3\缓存、负载均衡、存储
	4\图片服务器分离:图片是最消耗资源的，于是我们有必要将图片与页面进行分离
	5\node事件队列



10.可串行化
	可串行化调度是指多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同
	可串行性1.是并发事务正确调度的准则2.一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度

11.内存回收（Java 垃圾回收机制）
	Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理
	如果一个对象，没有一个引用指向它，那么它就被认为是一个垃圾。
	
12.java弱类型
	弱引用简单来说就是将对象留在内存的能力不是那么强的引用；垃圾回收器会帮你来决定引用的对象合适回收并且将对象从内存移除；解决强引用带来的内存泄漏的问题。

13.强引用带来的问题
	1.内存泄漏2.缓存




51\js多线程
	webworkers （ie不支持） 实现多线程  异步的执行JS 避免阻塞IO 
	浏览器中的JS是单线程的。
	解决客户端JavaScript无法多线程的问题，其定义的worker是指代码的并行线程，不过webworker处于一个自包含的环境中，无法访问主线程的window对象和document对象，和主线程通信只能通过异步消息传递机制

  具体操作
	我们需要把希望单独执行的javascript代码放到一个单独的js文件中，然后在页面中调用Worker构造函数来创建一个线程，参数是该文件路径，参数存放如果是相对地址，那么要以包含调用Worker构造函数语句所在脚本为参照，如果是绝对路径，需要保证同源（协议+主机+端口）

	我们可以看到worker对象只有两个属性，其实是两个回调函数句柄
	onerror:当worker运行出现错误，并且没有在worker中ing捕获，会在此捕获
	onmessage:当worker向主线程发送消息是调用

	在其prototype内有两个重要方法
	postMessage:很熟悉的赶脚，之前我们介绍过window对象的postMessage()方法，woker的postMessage方法和window的比较类似，但参数略有不同，只需要传递消息内容就可以，而且支持所有JavaScript原生数据类型，当然不放心的话同样也可以序列化为字符串传递
	terminate:终止worker执行，有些worker执行比较慢，主线程可以主动终止其执行



57\js垃圾回收:
	目前JS的垃圾回收机制无非就是两种：1.标记清除（make-and-sweep） 2.引用计数（reference counting）
	1.标记清除：标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。
	2.引用计数（查了很多资料，还是无法找到其真正的计算方式）
	一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收。


13\Websocket：基于TCP/IP协议的，双向的、全双工的数据连接
           双向的：客户端、服务器端
           全双工：数据的发送与接收，两者同步进行

	<首先Websocket是ws协议,但是是基于HTTP协议的，借用了HTTP的协议来完成一部分握手。这段类似HTTP协议的握手请求中，多了几个东西。
	这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。

	至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。

	但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。

	服务端就可以主动推送信息给客户端啦!>

	在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。


	
	long poll：
	 客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。

	其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话）
	ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发

	哦对了，忘记说了HTTP还是一个状态协议。
	通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。



进程与线程

    进程，《是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。》
    	每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。
    	进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

    线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。
    《线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。》

  区别：
 	《进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；》
    《反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。！！！！！》

   《进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的pcb。》这是进程宏观上的执行过程。而进程又可有单线程进程与多线程进程两种。我们知道，进程有 一个进程控制块 PCB ，相关程序段 和 该程序段对其进行操作的数据结构集 这三部分，单线程进程的执行过程在宏观上是线性的，微观上也只有单一的执行过程；而多线程进程在宏观上的执行过程同样为线性的，但微观上却可以有多个执行操作（线程），如不同代码片段以及相关的数据结构集。

    《线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。除了CPU之外，计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。》与进程控制表和 PCB 相似，每个线程也有自己的线程控制表 TCB ，而这个 TCB 中所保存的线程状态信息则要比 PCB 表少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈），寄存器中的状态数据。

   
    线程可以有效地提高系统的执行效率，但并不是在所有计算机系统中都是适用的，如某些很少做进程调度和切换的实时系统。使用线程的好处是有多个任务需要处理机处理时，减少处理机的切换时间；而且，线程的创建和结束所需要的系统开销也比进程的创建和结束要小得多。最适用使用线程的系统是多处理机系统和网络系统或分布式系统。

----------------------------------

1. 线程的执行特性。

    线程只有 3 个基本状态：就绪，执行，阻塞。

    线程存在 5 种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束。

2. 进程通信。

    单机系统中进程通信有 4 种形式：主从式，会话式，消息或邮箱机制，共享存储区方式。

        主从式典型例子：终端控制进程和终端进程。

        会话式典型例子：用户进程与磁盘管理进程之间的通信。



算法题

 排序:
	1、直接插入排序：
		①   思想：最基本的插入排序，将第i个插入到前i-1个中的适当位置。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
	2、折半插入排序：
		①   思想：因为是已经确定了前部分是有序序列，所以在查找插入位置的时候可以用折半查找的方法进行查找，提高效率。
		②   时间复杂度：比较时的时间减为O(n㏒n)，但是移动元素的时间耗费未变，所以总是得时间复杂度还是O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：稳定排序。

	3、希尔排序：
		①   思想：又称缩小增量排序法。把待排序序列分成若干较小的子序列，然后逐个使用直接插入排序法排序，最后再对一个较为有序的序列进行一次排序，主要是为了减少移动的次数，提高效率。原理应该就是从无序到渐渐有序，要比直接从无序到有序移动的次数会少一些。
		②   时间复杂度：O(n的1.5次方)
		③   空间复杂度：O(1)
		④   稳定性：不稳定排序。{2,4,1,2}，2和1一组4和2一组，进行希尔排序，第一个2和最后一个2会发生位置上的变化。

	1、冒泡排序：
		①   思想：反复扫描待排序序列，在扫描的过程中顺次比较相邻的两个元素的大小，若逆序就交换位置。第一趟，从第一个数据开始，比较相邻的两个数据，（以升序为例）如果大就交换，得到一个最大数据在末尾；然后进行第二趟，只扫描前n-1个元素，得到次大的放在倒数第二位。以此类推，最后得到升序序列。如果在扫描过程中，发现没有交换，说明已经排好序列，直接终止扫描。所以最多进行n-1趟扫描。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：稳定排序。。

	2、  快速排序：
		①   思想：冒泡排序一次只能消除一个逆序，为了能一次消除多个逆序，采用快速排序。以一个关键字为轴，从左从右依次与其进行对比，然后交换，第一趟结束后，可以把序列分为两个子序列，然后再分段进行快速排序，达到高效。
		②   时间复杂度：平均T(n) = O(n㏒n)，最坏O(n²)。
		③   空间复杂度：S(n) = O(㏒n)。
		④   稳定性：不稳定排序。{3， 2， 2}

	1、简单选择排序：
		①   思想：第一趟时，从第一个记录开始，通过n – 1次关键字的比较，从n个记录中选出关键字最小的记录，并和第一个记录进行交换。第二趟从第二个记录开始，选择最小的和第二个记录交换。以此类推，直至全部排序完毕。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：不稳定排序，{3， 3， 2}。

	2、树形选择排序：
		①   思想：为了减少比较次数，两两进行比较，得出的较小的值再两两比较，直至得出最小的输出，然后在原来位置上置为∞，再进行比较。直至所有都输出。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：较简单选择排序，增加了n-1个额外的存储空间存放中间比较结果，就是树形结构的所有根节点。S(n) = O(n)。
		④   稳定性：稳定排序。

	3、  堆排序：
		①   思想：把待排序记录的关键字存放在数组r[1…n]中，将r看成是一刻完全二叉树的顺序表示，每个节点表示一个记录，第一个记录r[1]作为二叉树的根，一下个记录r[2…n]依次逐层从左到右顺序排列，任意节点r[i]的左孩子是r[2i]，右孩子是r[2i+1]，双亲是r[i/2向下取整]。然后对这棵完全二叉树进行调整建堆。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：不稳定排序。

	4、归并排序：
		①   思想：假设初始序列右n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2向上取整 个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列。在此基础上，在对长度为2的有序子序列进行两两归并，得到若干个长度为4的有序子序列。如此重复，直至得到一个长度为n的有序序列为止。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：S(n) = O(n)。
		④   稳定性：稳定排序。

	总结：
	（1）简单排序法一般只用于n较小的情况（例如n<30）。当序列的记录“基本有序”时，直接插入排序是最佳的排序方法。如果记录中的数据较多，则应采用移动次数较少的简单选择排序法。

	（2）快速排序、堆排序和归并排序的平均时间复杂度均为O(n㏒n)，但实验结果表明，就平均时间性能而言，快速排序是所有排序方法中最好的。遗憾的是，快速排序在最坏情况下的时间性能为O(n²)。堆排序和归并排序的最坏时间复杂度仍为O(n㏒n)，当n较大时，归并排序的时间性能优于堆排序，但它所需的辅助空间最多。

	（3）从排序的稳定性上来看，在所有简单排序法中，简单选择排序是不稳定的，其他各种简单排序法都是稳定的。然而，在那些时间性能较好的排序方法中，希尔排序、快速排序、堆排序都是不稳定的，只有归并排序、基数排序是稳定的。




不借助临时变量，进行两个整数的交换
	主要是利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b;
	 	b = b - a;
	  	a = a + b;
	 	b = a - b;


实现类似getElementsByClassName 的功能
	自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。

	JavaScript

	function queryClassName(node, name) {  
	  var starts = '(^|[ \n\r\t\f])',
	       ends = '([ \n\r\t\f]|$)';
	  var array = [],
	        regex = new RegExp(starts + name + ends),
	        elements = node.getElementsByTagName("*"),
	        length = elements.length,
	        i = 0,
	        element;

	    while (i < length) {
	        element = elements[i];
	        if (regex.test(element.className)) {
	            array.push(element);
	        }

	        i += 1;
	    }

	    return array;
	}

深度优先遍历:也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点
广度优先遍历:也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。所以要遍历完当前节点的所有孩子，这样才是层次遍历嘛。




前端页面性能问题??????

	node异步回调





计算机网络：
TCP/IP五层网络架构:
	一、物理层:它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号
	二、数据链路层:这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。
			以太网协议:一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）
			MAC地址:以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址

			广播:1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"
				，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"
			  一块网卡怎么会知道另一块网卡的MAC地址？回答是有一种ARP协议;
				就算有了MAC地址，系统怎样才能把数据包准确送到接收方？
				回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

	三、网络层:跟路由打交道;识别经历了多少个路由,路由表,(用ARP,ip)
		这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这			套地址就叫做"网络地址"，简称"网址"。
		IP协议:规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。
		IP数据包:根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息
		ARP协议:总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。

	四、传输层:有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
		"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。
	    
		 UDP协议:现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。
  		UDP/ TCP区别:
  			UDP不安全,TCP安全
  		  UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。
		  为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。
		  因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

	五、应用层:就是规定应用程序的数据格式。系统级别ftp，http，qq	包裹相应内容（图片，）



OSI七层:
	OSI中的层 功能 TCP/IP协议族

	物理层: 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2
	数据链路层:传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU
	网络层: 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP
	传输层: 提供端对端的接口 TCP，UDP
	会话层: 解除或建立与别的接点的联系 没有协议(tcp/ip协议栈socket 联通另外机器创建连接)
	表示层: 数据格式化，代码转换，数据加密 没有协议(把应用层翻译过来,主要做数据格式的转换,md5($pass) css html setEncoding('utf-8'),监听端口.http打包数据)
	应用层: 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet


	tcp/ip的协议栈包裹567;提供一个接口.socket原生解决(如何绑定端口等等)
	传输(单向传输 半双工<只能接受或者发出> 全双工)





10\在浏览器地址栏里输入一个地址，按回车发生了什么？
	1. 浏览器会发送一个get请求，该请求会被转发到DNS服务器，由DNS服务器解析域名，然后再转发到相应的IP地址对应的服务器。
	2. 在服务器端由Apache这样的Web Server来接收请求，并进行相应的处理，然后响应结果给客户端浏览器。
	3. 浏览器接收响应的结果，并进行相应的语法检查，如果有错误，可能会提示错误，如果没有错误，就进行渲染。
	4. 渲染的时候先生成DOM树，然后根据CSS和JS规则生成渲染树（渲染树中的结构往往比DOM树要少，因为有些DOM树中有些元素如果隐藏的话，不会出现在渲染树中），最后再渲染出来


27\浏览器是怎么把html文档解析成DOM结构的
 	渲染引擎会解析ＨＴＭＬ文档并把标签转换成内容树中的ＤＯＭ节点。它会解析style元素和外部文件中的样式数据。样式数据和ＨＴＭＬ中的显示控制将共同用来创建另一棵树——渲染树。然后再布局，webkit叫渲染树/Geko叫帧树

11\TCP三次握手：建立连接
	 (1)Client端向Server端发送一个SYN包，请求建立连接。
	 (2)Server端收到SYN包后，会发送一个SYN/ACK确认包回去，表示对第一个SYN包的确认。
	 (3)Client端收到SYN/ACK包后，会发送一个ACK确认包，通知Server连接已建立。

11.1\TCP建立连接为什么需要三次握手，两次不行吗？
答：在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

12\TCP四次挥手：关闭连接
	(1) Client端向Server端FIN报文，请求关闭连接
	(2) Server端发送ACK，表示收到请求。但是Server端还有数据没有发送完成，则不必着急关闭Socket，可以继续发送数据。这时Client端进入FIN_WAIT状态，等待Server端的FIN报文。
	(3)当Server端确定数据已发送完成，则向Client端发送FIN报文，表明可以关闭连接了
	(4)Client端收到FIN报文后，知道可以关闭连接了，再发送ACK，后进入TIME_WAIT状态，Client端等待了2MSL(最大报文生存时间)后依然没有收到回复，则证明Server端已正常关闭，然后Client端也可以关闭连接了，进入Closed状态。
	Server端收到ACK后，就关闭连接了。如果Server端没有收到ACK，那么将重发FIN。


13\http/https:
	HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。
	为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
	简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

14\HTTPS和HTTP的区别主要如下：
	1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

15\http缓存：HTTP缓存，明确的要知道GET请求可以被缓存，POST不能被缓存，所以要想在客户端做HTTP的缓存一定要注意使用GET请求！
  两种方式:
	If-Modified-Since/Last-Modified
	If-Modified-Since这个是在Request里面的Cache中的信息用来表示本地缓存最后一次被修改的时间，他被发送到服务器并且和Response的Entity中Last-Modified作比较，如果两者的日期一致，那就说明在此期间页面没有任何改动浏览器可以使用本地缓存。（所提到的头域都可以在上面图中找到，大家结合图来看比较清晰）

	If-None-Match/Etag
	If-None-Match是在Request中请求头的第一行，他存储一个字符串（资源在服务器的唯一确定标志）。Etag是Response中Entity中的一个字符串。两个也是做比较，相同说明可以使用缓存。

http协商缓存中：Etag/lastModified完整过程（可以配合上面的HTTP流程理解）：
	1.客户端请求一个页面（A）。2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存.4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。







会话连接,和传输连接有什么区别???


nodejs怎么用req,res收发包
怎么接收怎么发出的


什么叫前后端分离
让控制器层也让前端写,降低冲突

node是如何做中间层的;(事件驱动,事件队列)
写控制器,express解决
处理json(远程调用/UDP服务器)


php是后端渲染,

